(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],2:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = {
	cacheStore: new Object({

	}),
	checkCache: (fn, input, dataType) => {
    let cachedResult = this.cacheStore[fn];
    if(cachedResult) {
      if(cachedResult[0] === input && cachedResult[2] === dataType) {
        return cachedResult;
      }
    }
  },
  cacheOutput: (fn, inputArray, output, dataType) => {
    this.cacheStore[fn] = [inputArray, output, dataType];
  }
};
},{}],3:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const supportsWorkers = require("./support/worker");
const supportsTransferrableObjects = require("./support/transferrable-object");
const supportsSharedWorkers = require("./support/shared-worker");
const supportsAtomics = require("./support/atomics");

const isNode = require("./detect/node");
const isBrowser = require("./detect/browser");
const isShell = require("./detect/shell");
const isReactNative = require("./detect/reactNative");
const isWorker = require("./detect/worker");
const isInternetExplorerTen = require("./detect/internetExplorerTen");
const isLegacy = require('./detect/legacy');

module.exports = {
	node: isNode,
	browser: isBrowser,
	worker: isWorker,
	reactNative: isReactNative,
	shell: isShell,
	atomics: supportsAtomics,
	transferrable: supportsTransferrableObjects,
	ie10: isInternetExplorerTen,
	legacy: isLegacy
};
},{"./detect/browser":4,"./detect/internetExplorerTen":5,"./detect/legacy":6,"./detect/node":7,"./detect/reactNative":8,"./detect/shell":9,"./detect/worker":10,"./support/atomics":12,"./support/shared-worker":13,"./support/transferrable-object":14,"./support/worker":15}],4:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const isBrowser = () => {
	return (typeof window === "object");
};

module.exports = isBrowser();
},{}],5:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const isBrowser = require("./browser");

const isInternetExplorer = (version) => {
	if(typeof navigator === "undefined" || !isBrowser) {
		return false;
	}
	return (new RegExp('msie' + (!isNaN(version) ? ('\\s'+version) : ''), 'i').test(navigator.userAgent));
};

module.exports = isInternetExplorer(10);
},{"./browser":4}],6:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const supportsWorkers = require("../support/worker");
const supportsSharedWorkers = require("../support/shared-worker");
const isWorker = require("./worker");
const isShell = require("./shell");

const isLegacy = () => {
	if(isShell) {
		return true;
	}
	if(isWorker) {
		return !supportsSharedWorkers;
	}
	return !supportsWorkers;
};

module.exports = isLegacy();
},{"../support/shared-worker":13,"../support/worker":15,"./shell":9,"./worker":10}],7:[function(require,module,exports){
(function (process){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const isNode = () => {
	return (typeof process === "object" && typeof require === "function");
};

module.exports = isNode();
}).call(this,require("rH1JPG"))
},{"rH1JPG":1}],8:[function(require,module,exports){
(function (global){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const isNode = require("./node");

const isReactNative = () => {
	return (isNode === false && typeof global === "object");
};

module.exports = isReactNative();
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./node":7}],9:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const isBrowser = require("./browser");
const isNode = require("./node");
const isWorker = require("./worker");
const isReactNative = require("./reactNative");

const isShell = () => {
	return (!isBrowser && !isNode && !isWorker && !isReactNative);
};

module.exports = isShell();
},{"./browser":4,"./node":7,"./reactNative":8,"./worker":10}],10:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const isWorker = () => {
	return (typeof importScripts === "function");
};

module.exports = isWorker();







},{}],11:[function(require,module,exports){
(function (global){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

let detectedEnvironment = require("./detect-environment");
let maxThreads = 4;
let threads = [];
let uri = null;

const setupBrowserSupport = () => {
	if(['Kindle/3.0', 'Mobile/8F190', 'IEMobile'].indexOf(navigator.userAgent) !== -1) {
    detectedEnvironment.legacy = true;
  }
  if(navigator.userAgent.toLowerCase().indexOf('firefox') !== -1) {
    detectedEnvironment.maxThreads = (maxThreads > 20 ? 20 : maxThreads);
  }
  
  if(detectedEnvironment.ie10) {
    console.info("Explicit worker support for Internet Explorer 10 is being deprecated, please upgrade your browser.");
    try {
      var hamster = new Worker('../../common/wheel.min.js');
      hamster.terminate();
    } catch(e) {
      detectedEnvironment.legacy = true;
    }
  }
};

if(typeof navigator !== "undefined") {
  detectedEnvironment.maxThreads = navigator.hardwareConcurrency;
}

if(detectedEnvironment.browser) {
  setupBrowserSupport();
}

if(detectedEnvironment.reactNative || detectedEnvironment.node) {
  global.self = global;
}
 
module.exports = detectedEnvironment;
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./detect-environment":3}],12:[function(require,module,exports){

/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const supportsAtomics = () => {
	return (typeof SharedArrayBuffer !== 'undefined');
};

module.exports = supportsAtomics();
},{}],13:[function(require,module,exports){

/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const supportsSharedWorkers = () => {
	return (typeof SharedWorker !== 'undefined');
};

module.exports = supportsSharedWorkers();
},{}],14:[function(require,module,exports){

/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const supportsTransferrableObjects = () => {
	return (typeof Uint8Array !== "undefined");
};

module.exports = supportsTransferrableObjects();
},{}],15:[function(require,module,exports){

/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const supportsWorkers = () => {
	return (typeof Worker !== 'undefined');
};

module.exports = supportsWorkers();
},{}],16:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

// const newTask = require('./wheel/task/new-task');
// const hamsterEnvironment = require('./environment/setup-environment');
// const executeTask = require('./wheel/task/execute-task');
// const runningTasks = require('./pool/thread-pool').runningTasks;

// module.exports = (threadParams, functionToExecute, onSuccess, numberOfThreads, aggregateThreadOutputs, dataType, memoize, order) => {
//   var totalWorkers = numberOfThreads;
//   if(hamsterEnvironment.legacy) {
//     totalWorkers = 1;
//   }
//   var task = newTask(runningTasks.length, totalWorkers, order, dataType, functionToExecute, onSuccess);
//   if(dataType) {
//     dataType = dataType.toLowerCase();
//   }
//   // if(hamsters.cache && memoize) {
//   //   var result = this.wheel.checkCache(functionToExecute, task.input, dataType);
//   //   if(result) {
//   //     setTimeout(function() {
//   //       hamsters.wheel.tasks[taskid] = null; //Clean up our task, not needed any longer
//   //       onSuccess(result);
//   //     }, 4);
//   //     return;
//   //   }
//   // }
//   executeTask(task, threadParams, functionToExecute, onSuccess, aggregateThreadOutputs, dataType, memoize, order);
// };


"use strict";

module.exports = {};
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

var environment = require('./environment/setup-environment');
var hamsterTools = require("./tools/setup");
var memoizer = require("./cache/memoizer");
var threadPool = require("./pool/thread-pool");
var createBlob = require("./wheel/data/create-blob");
var giveHamsterWork = require("./processor/hamster-worker");
var getOutput = require('./wheel/data/get-output');
var cleanTask = require('./wheel/task/clean-task/');
var feedHamster = require('./wheel/thread/feed-hamster');
var prepareFunction = require('./wheel/task/prepare-function');
var splitArray = hamsterTools.splitArray;
var aggregate = hamsterTools.aggregate;
var sort = hamsterTools.sort;

var threads = [];

var processStartOptions = function processStartOptions(startOptions) {
  for (var key in startOptions) {
    if (startOptions.hasOwnProperty(key)) {
      hamsters[key] = startOptions[key];
    }
  }
};

var spawnHamsters = function spawnHamsters() {
  if (environment.browser) {
    var uri = URL.createObjectURL(createBlob('(' + String(giveHamsterWork()) + ')();'));
  }
  if (environment.persistence) {
    var i = environment.maxThreads;
    for (i; i > 0; i--) {
      if (environment.ie10) {
        threads.push(new Worker('./common/wheel.min.js'));
      } else if (environment.node) {
        threads.push(new Worker(giveHamsterWork()));
      } else if (environment.worker) {
        threads.push(new SharedWorker(uri, 'SharedHamsterWheel'));
      } else {
        threads.push(new Worker(uri));
      }
    }
  }
};

var workerWorker = function workerWorker() {
  addEventListener("connect", function (e) {
    var port = e.ports[0];
    port.start();
    port.addEventListener("message", function (e) {
      self.rtn = {
        success: true,
        data: []
      };
      self.params = e.data;
      self.fn = eval("(" + params.fn + ")");
      if (fn) {
        self.fn();
      }
      if (self.params.dataType && self.params.dataType != "na") {
        self.rtn.data = self.processDataType(self.params.dataType, self.rtn.data);
        self.rtn.dataType = self.params.dataType;
      }
      port.postMessage({
        results: self.rtn
      });
    }, false);
  }, false);
};

var worker = function worker() {
  var processDataType = function processDataType(dataType, buffer) {
    var types = {
      'uint32': Uint32Array,
      'uint16': Uint16Array,
      'uint8': Uint8Array,
      'uint8clamped': Uint8ClampedArray,
      'int32': Int32Array,
      'int16': Int16Array,
      'int8': Int8Array,
      'float32': Float32Array,
      'float64': Float64Array
    };
    if (!types[dataType]) {
      return buffer;
    }
    return new types[dataType](buffer);
  };
  onmessage = function onmessage(e) {
    self.params = e.data;
    self.rtn = {
      data: [],
      dataType: self.params.dataType
    };
    var fn = new Function(self.params.fn);
    if (fn) {
      fn();
    }
    if (self.params.dataType) {
      self.rtn.data = processDataType(self.params.dataType, self.rtn.data);
      self.postMessage({
        results: self.rtn
      }, [rtn.data.buffer]);
    } else {
      self.postMessage({
        results: self.rtn
      });
    }
  };
};

var legacyHamsterWheel = function legacyHamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, threadId, hamster, memoize) {
  trackThread(task, queue.running, threadId);
  if (memoize || hamsters.debug) {
    trackInput(inputArray, threadId, task, hamsterFood);
  }
  legacyProcessor(hamsterFood, inputArray, function (output) {
    clean(task, threadId);
    task.output[threadId] = output.data;
    if (task.workers.length === 0 && task.count === task.threads) {
      onSuccess(getOutput(task.output, aggregate, output.dataType));
      tasks[task.id] = null;
      if (hamsters.cache && memoize !== false) {
        memoize(task.fn, task.input, output.data, output.dataType);
      }
    }
  });
  task.count += 1; //Thread finished
};

var hamsterWheel = function hamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, threadId, hamster, memoize) {
  // hamsterFood.array = inputArray;

  if (hamsters.maxThreads === queue.running.length) {
    poolThread(inputArray, hamsterFood, threadId, onSuccess, task, aggregate, memoize);
    return;
  }
  if (memoize || hamsters.debug) {
    trackInput(inputArray, threadId, task, hamsterFood);
  }
  if (!hamster) {
    if (hamsters.persistence) {
      hamster = hamsters[queue.running.length];
    } else {
      if (environment.ie10) {
        hamster = new Worker('src/common/wheel.min.js');
      } else if (environment.worker) {
        hamster = new SharedWorker(uri, 'SharedHamsterWheel');
      } else if (environment.node) {
        hamster = new Worker(giveHamsterWork());
      } else {
        hamster = new Worker(uri);
      }
    }
  }
  trainHamster(threadId, aggregate, onSuccess, task, hamster, memoize);
  trackThread(task, queue.running, threadId);
  feedHamster(hamster, hamsterFood);
  task.count += 1; //Increment count, thread is running
  if (hamsters.debug === 'verbose') {
    console.info('Spawning Hamster #' + threadId + ' @ ' + new Date().getTime());
  }
};

var loop = function loop(input, onSuccess) {
  var params = {
    run: prepareFunction(input.operator),
    init: input.startIndex || 0,
    limit: input.limit,
    array: input.array,
    incrementBy: input.incrementBy || 1,
    dataType: input.dataType || null,
    worker: env.worker
  };
  run(params, function () {
    var operator = self.params.run;
    if (typeof operator === "string") {
      if (params.worker) {
        operator = eval("(" + operator + ")");
      } else {
        operator = new Function(operator);
      }
    }
    if (!params.limit) {
      params.limit = params.array.length;
    }
    var i = params.init;
    for (i; i < params.limit; i += params.incrementBy) {
      rtn.data[i] = operator(params.array[i]);
    }
  }, function (rtn) {
    onSuccess(rtn);
  }, input.threads, 1, input.dataType);
};

var checkCache = function checkCache(fn, input, dataType) {
  var cachedResult = cache[fn];
  if (cachedResult) {
    if (cachedResult[0] === input && cachedResult[2] === dataType) {
      return cachedResult;
    }
  }
};

var memoize = function memoize(fn, inputArray, output, dataType) {
  hamsters.cache[fn] = [inputArray, output, dataType];
};

var run = function run(params, fn, onSuccess, workers, aggregate, dataType, memoize, order) {
  if (!params || !fn) {
    return 'Error processing for loop, missing params or function';
  }
  workers = environment.legacy ? 1 : workers || 1;
  var task = newTask(tasks.length, workers, order, dataType, fn, onSuccess);
  if (dataType) {
    dataType = dataType.toLowerCase();
  }
  if (hamsters.cache && memoize) {
    var result = checkCache(fn, task.input, dataType);
    if (result && onSuccess) {
      setTimeout(function () {
        tasks[taskid] = null; //Clean up our task, not needed any longer
        onSuccess(result);
      }, 4);
      return;
    }
  }
  work(task, params, fn, onSuccess, aggregate, dataType, memoize, order);
};

var prepareMeal = function prepareMeal(params, fn, dataType) {
  var food = {};
  var key;
  for (key in params) {
    if (params.hasOwnProperty(key) && key !== 'array') {
      food[key] = params[key];
    }
  }
  food.fn = prepareFunction(fn);
  food.dataType = dataType;
  return food;
};

var work = function work(task, params, fn, onSuccess, aggregate, dataType, memoize, order) {
  var workArray = params.array;
  if (workArray && task.threads !== 1) {
    workArray = splitArray(workArray, task.threads); //Divide our array into equal array sizes
  }
  var food = prepareMeal(params, fn, dataType);
  var i = 0;
  while (i < task.threads) {
    if (workArray && task.threads !== 1) {
      newWheel(workArray[i], food, aggregate, onSuccess, task, task.count, null, memoize);
    } else {
      newWheel(workArray, food, aggregate, onSuccess, task, task.count, null, memoize);
    }
    i += 1;
  }
};

var assignOutput = function assignOutput(task, inputArray) {
  if (!task || !inputArray || !environment.atomics) {
    return;
  }
  task.output = new SharedArrayBuffer(inputArray.length);
};

var trackInput = function trackInput(inputArray, threadId, task, hamsterFood) {
  task.input.push({
    input: inputArray,
    workerid: threadId,
    taskid: task.id,
    params: hamsterFood,
    start: new Date().getTime()
  });
};

var trackThread = function trackThread(task, running, id) {
  task.workers.push(id); //Keep track of threads scoped to current task
  running.push(id); //Keep track of all currently running threads
};

var poolThread = function poolThread(inputArray, hamsterFood, threadId, cb, task, agg, memoize) {
  queue.pending.push({
    memoize: memoize,
    input: inputArray,
    params: hamsterFood,
    workerid: threadId,
    onSuccess: cb,
    task: task,
    aggregate: agg
  });
};

var legacyProcessor = function legacyProcessor(params, inputArray, onSuccess) {
  setTimeout(function () {
    self.rtn = {
      success: true,
      data: []
    };
    self.params = params;
    self.params.array = inputArray;
    self.params.fn();
    if (self.params.dataType && self.params.dataType != "na") {
      self.rtn.data = processDataType(self.params.dataType, self.rtn.data);
      self.rtn.dataType = self.params.dataType;
    }
    onSuccess(self.rtn);
  }, 4); //4ms delay (HTML5 spec minimum), simulate threading
};

var processQueue = function processQueue(hamster, item) {
  if (!item) {
    return;
  }
  newWheel(item.input, item.params, item.aggregate, item.onSuccess, item.task, item.workerid, hamster, item.memoize); //Assign most recently finished thread to queue item
};

var trainHamster = function trainHamster(id, aggregate, onSuccess, task, hamster, memoize) {
  var onmessage = function onmessage(e, results) {
    clean(task, id);
    results = e.data.results;
    task.output[id] = results.data;
    if (hamsters.debug === 'verbose') {
      console.info('Hamster #' + id + ' finished ' + '@ ' + e.timeStamp);
    }
    if (task.workers.length === 0 && task.count === task.threads) {
      if (task.order) {
        onSuccess(sort(getOutput(task.output, aggregate, results.dataType), task.order));
      } else {
        onSuccess(getOutput(task.output, aggregate, results.dataType));
      }
      // if(hamsters.debug) { Revisit, completely inaccurate!!!
      //   console.info('Execution Complete! Elapsed: ' + ( (e.timeStamp - task.input[0].start) / 1000) + 's');
      // }
      tasks[task.id] = null; //Clean up our task, not needed any longer
      if (hamsters.cache && memoize) {
        if (task.output[id] && !task.output[id].slice) {
          memoize(task.fn, task.input[0].input, normalizeArray(output), results.dataType);
        } else {
          memoize(task.fn, task.input[0].input, getOutput(task.output, aggregate, results.dataType), results.dataType);
        }
      }
    }
    if (queue.pending.length !== 0) {
      processQueue(hamster, queue.pending.shift());
    } else if (!hamsters.persistence && !environment.worker) {
      hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)
    }
  };

  var onerror = function onerror(e) {
    if (!environment.worker) {
      hamster.terminate(); //Kill the thread
    }
    errors.push({
      msg: 'Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message
    });
    console.error('Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message);
  };

  if (environment.worker) {
    hamster.port.onmessage = onmessage;
    hamster.port.onerror = onerror;
  } else {
    hamster.onmessage = onmessage;
    hamster.onerror = onerror;
  }
};

var processData = function processData(dataType, buffer) {
  var types = {
    'uint32': Uint32Array,
    'uint16': Uint16Array,
    'uint8': Uint8Array,
    'uint8clamped': Uint8ClampedArray,
    'int32': Int32Array,
    'int16': Int16Array,
    'int8': Int8Array,
    'float32': Float32Array,
    'float64': Float64Array
  };
  if (!types[dataType]) {
    return dataType;
  }
  return new types[dataType](buffer);
};

var processDataType = function processDataType(dataType, buffer) {
  if (environment.transferrable) {
    return processData(dataType, buffer);
  }
  return buffer;
};

self.hamsters = {
  version: '4.1.4',
  init: function init(startOptions) {
    processStartOptions(startOptions);
    if (environment.legacy) {
      var newWheel = legacyHamsterWheel;
    } else {
      var newWheel = hamsterWheel;
      spawnHamsters();
    }
  },
  debug: false,
  cache: false,
  persistence: true,
  maxThreads: 4,
  habitat: environment,
  atomics: false,
  tools: hamsterTools(),
  wheel: {
    cache: {},
    hamsters: threads,
    errors: [],
    uri: null
  }
};

module.exports = hamsters;
},{"./cache/memoizer":2,"./environment/setup-environment":11,"./pool/thread-pool":18,"./processor/hamster-worker":19,"./tools/setup":32,"./wheel/data/create-blob":33,"./wheel/data/get-output":34,"./wheel/task/clean-task/":38,"./wheel/task/prepare-function":39,"./wheel/thread/feed-hamster":40}],17:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

// const newTask = require('./wheel/task/new-task');
// const hamsterEnvironment = require('./environment/setup-environment');
// const executeTask = require('./wheel/task/execute-task');
// const runningTasks = require('./pool/thread-pool').runningTasks;

// module.exports = (threadParams, functionToExecute, onSuccess, numberOfThreads, aggregateThreadOutputs, dataType, memoize, order) => {
//   var totalWorkers = numberOfThreads;
//   if(hamsterEnvironment.legacy) {
//     totalWorkers = 1;
//   }
//   var task = newTask(runningTasks.length, totalWorkers, order, dataType, functionToExecute, onSuccess);
//   if(dataType) {
//     dataType = dataType.toLowerCase();
//   }
//   // if(hamsters.cache && memoize) {
//   //   var result = this.wheel.checkCache(functionToExecute, task.input, dataType);
//   //   if(result) {
//   //     setTimeout(function() {
//   //       hamsters.wheel.tasks[taskid] = null; //Clean up our task, not needed any longer
//   //       onSuccess(result);
//   //     }, 4);
//   //     return;
//   //   }
//   // }
//   executeTask(task, threadParams, functionToExecute, onSuccess, aggregateThreadOutputs, dataType, memoize, order);
// };
},{}],18:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const newWheel = require("../wheel/hamster-wheel");
const newHamster = require("../wheel/thread/new-hamster");
const giveHamsterWork = require("../processor/hamster-worker");

module.exports = {
	pendingTasks: [],
	runningTasks: [],
	activeThreads: [],
	spawnHamsters: (persistence, number) => {
	  if(typeof URL !== "undefined") {
	    uri = URL.createObjectURL(createBlob("(" + String(giveHamsterWork()) + ")();"));
	  }
	  if(persistence) {
	    let i = number;
	    for (i; i > 0; i--) {
	      this.activeThreads.push(newHamster());
	    }
	  }
	},
	poolThread: (inputArray, hamsterfood, threadid, cb, task, agg, memoize) => {
    pendingTasks.push({
      memoize: memoize,
      input: inputArray,
      params: hamsterfood,
      workerid: threadid, 
      callback: cb, 
      task: task,
      aggregate: agg
    });
  },
  processQueue: (hamster, item) => {
    if(!item) {
      return;
    }
    newWheel(item.input, item.params, item.aggregate, item.callback, item.task, item.workerid, hamster, item.memoize); //Assign most recently finished thread to queue item
  },
  trackInput: (inputArray, threadid, task, hamsterfood) => {
  	const started = new Date().getTime();
    task.input.push({ 
      input: inputArray,
      workerid: threadid, 
      taskid: task.id, 
      params: hamsterfood, 
      start: started
    });
  },
  trackThread: (task, running, id) => {
    task.workers.push(id); //Keep track of threads scoped to current task
    runningTasks.push(id); //Keep track of all currently running threads
  },
  poolThread: (inputArray, hamsterfood, threadid, cb, task, agg, memoize) => {
    pendingTasks.push({
      memoize: memoize,
      input: inputArray,
      params: hamsterfood,
      workerid: threadid, 
      callback: cb, 
      task: task,
      aggregate: agg
    });
  }
};
},{"../processor/hamster-worker":19,"../wheel/hamster-wheel":37,"../wheel/thread/new-hamster":41}],19:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const environment = require("../environment/setup-environment");
const legacyWorker = require("./worker/legacy-worker");
const workerWorker = require("./worker/worker-worker");
const worker = require("./worker/worker");

module.exports = () => {
	if(environment.legacy) {
		return legacyWorker;
	}
	if(environment.worker) {
		return workerWorker;
	}
  return worker;
};

},{"../environment/setup-environment":11,"./worker/legacy-worker":22,"./worker/worker":24,"./worker/worker-worker":23}],20:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const legacyWorker = require("./worker/legacy-worker");
const trackThread = require("../pool/thread-pool").trackThread;
const trackInput = require("../pool/thread-pool").trackInput;
// const memoizer = require("./");
const cleanUpTask = require("../wheel/task/clean-task");

module.exports = (inputArray, hamsterFood, aggregate, onSuccess, task, threadId, hamster, memoize) => {
  trackThread(task, hamsters.wheel.queue.running, threadid);
  if(memoize || hamsters.debug) {
    trackInput(inputArray, threadId, task, hamsterFood);
  }
  legacyWorker((hamsterFood, inputArray, output) => {
    cleanUpTask(task, threadId);
    task.output[threadId] = output.data;
    if(task.workers.length === 0 && task.count === task.threads) {
      onSuccess(getOutput(task.output, aggregate, output.dataType));
      hamsters.wheel.tasks[task.id] = null;
      // if(hamsters.cache && memoize !== false) {
      //   memoize(task.fn, task.input, output.data, output.dataType);
      // }
    }
  });
  task.count += 1; //Thread finished
};
},{"../pool/thread-pool":18,"../wheel/task/clean-task":38,"./worker/legacy-worker":22}],21:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const trainHamster = require('../wheel/thread/train-hamster');
const newHamster = require('../wheel/thread/new-hamster');
const trackHamster = require('../pool/thread-pool').trackHamster;
const feedHamster = require('../wheel/thread/feed-hamster');
const threadPool = require('../pool/thread-pool');
// const memoizer = require('../cache/mmemoizer');

module.exports = (inputArray, parameters, aggregate, onSuccess, task, id, thread, memoize) => {
  if(maxThreads === queue.running.length) {
    threadPool.poolThread(inputArray, params, threadid, callback, task, aggregate, memoize);
    return;
  }
  if(memoize || debug) {
    trackInput(inputArray, threadid, task, hamsterfood);
  }
  if(!hamster) {
    if(hamsters.persistence) {
      hamster = hamsters.wheel.hamsters[hamsters.wheel.queue.running.length];
    } else {
      hamster = newHamster();
    }
  }
  trainHamster(threadid, aggregate, callback, task, hamster, memoize);
  trackThread(task, hamsters.wheel.queue.running, threadid);
  hamsterfood.array = inputArray;
  feedHamster(hamster, hamsterfood);
  task.count += 1; //Increment count, thread is running
  if(hamsters.debug === "verbose") {
    console.info("Spawning Hamster #" + threadid + " @ " + new Date().getTime());
  }
};
},{"../pool/thread-pool":18,"../wheel/thread/feed-hamster":40,"../wheel/thread/new-hamster":41,"../wheel/thread/train-hamster":44}],22:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = (params, inputArray, onSuccess) => {
  setTimeout(() => {
    self.rtn = {
      success: true, 
      data: []
    };
    self.params = params;
    self.params.array = inputArray;
    self.params.fn();
    if(self.params.dataType && self.params.dataType != "na") {
      self.rtn.data = processDataType(self.params.dataType, self.rtn.data);
      self.rtn.dataType = self.params.dataType;
    }
    onSuccess(self.rtn);
  }, 4); //4ms delay (HTML5 spec minimum), simulate threading
};

},{}],23:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = () => {
  function processDataType(dataType, buffer) {
    var types = {
      'uint32': Uint32Array,
      'uint16': Uint16Array,
      'uint8': Uint8Array,
      'uint8clamped': Uint8ClampedArray,
      'int32': Int32Array,
      'int16': Int16Array,
      'int8': Int8Array,
      'float32': Float32Array,
      'float64': Float64Array
    };
    if(!types[dataType]) {
      return buffer;
    }
    return new types[dataType](buffer);
  }

  self.addEventListener("connect", function(e) {
    var port = e.ports[0];
    port.start();
    port.addEventListener("message", function(e) {
      self.rtn = {
        success: true,
        data: []
      };
      self.params = e.data;
      self.fn = eval("(" + params.fn + ")");
      if (fn) {
        self.fn();
      }
      if(self.params.dataType && self.params.dataType != "na") {
        self.rtn.data = self.processDataType(self.params.dataType, self.rtn.data);
        self.rtn.dataType = self.params.dataType;
      }
      port.postMessage({
        results: self.rtn
      });
    }, false);
  }, false);
};

},{}],24:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = () => {
  function processDataType(dataType, buffer) {
    var types = {
      'uint32': Uint32Array,
      'uint16': Uint16Array,
      'uint8': Uint8Array,
      'uint8clamped': Uint8ClampedArray,
      'int32': Int32Array,
      'int16': Int16Array,
      'int8': Int8Array,
      'float32': Float32Array,
      'float64': Float64Array
    };
    if(!types[dataType]) {
      return buffer;
    }
    return new types[dataType](buffer);
  }
  self.onmessage = function(e) {
    self.params = e.data;
    self.rtn = {
      data: [],
      dataType: self.params.dataType
    };
    var fn = new Function(self.params.fn);
    if(fn) {
      fn();
    }
    if(self.params.dataType) {
      self.rtn.data = processDataType(self.params.dataType, self.rtn.data);
      self.postMessage({
        results: self.rtn
      }, [rtn.data.buffer]);
    } else {
      self.postMessage({
        results: self.rtn
      });
    }
  };
};

},{}],25:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = (input, onSuccess) => {
  let params = {
    run: prepareFunction(input.operator),
    init: input.startIndex || 0,
    limit: input.limit,
    array: input.array,
    incrementBy: input.incrementBy || 1,
    dataType: input.dataType || null,
    worker: environment.worker
  };

  run(params, () => {
    let operator = params.run;
    if(typeof operator === "string") {
      if(params.worker) {
        operator = eval("(" + operator + ")");
      } else {
        operator = new Function(operator);
      }
    }
    if(!params.limit) {
      params.limit = params.array.length;
    }
    let i = params.init;
    for (i; i < params.limit; i += params.incrementBy) {
      rtn.data[i] = operator(params.array[i]);
    }
  }, (output) => {
    onSuccess(output);
  }, input.threads, 1, input.dataType);
};
},{}],26:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const environment = require("../../environment/setup-environment");
const processDataType = require("../../wheel/data/process-data").processDataType;

module.exports = (input, dataType) => {
  if(!dataType || !environment.transferrable) {
    return input.reduce((a, b) => a.concat(b));
  }
  let i = 0;
  let len = input.length;
  let bufferLength = 0;
  for (i; i < len; i += 1) {
    bufferLength += input[i].length;
  }
  let output = processDataType(dataType, bufferLength);
  let offset = 0;
  for (i = 0; i < len; i += 1) {
    output.set(input[i], offset);
    offset += input[i].length;
  }
  return output;
};
},{"../../environment/setup-environment":11,"../../wheel/data/process-data":36}],27:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const executeTask = require("../../hamsters-run");

module.exports = (inputAmount, onSuccess) => {
  var params = {
    count: inputAmount
  };
  executeTask(params, () => {
    while(params.count > 0) {
      rtn.data[rtn.data.length] = Math.round(Math.random() * (100 - 1) + 1);
      params.count -= 1;
    }
  }, (result) => {
    onSuccess(result);
  });
};
},{"../../hamsters-run":17}],28:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = (arr, order) => {
  switch(order) {
    case "desc":
    case "asc":
      return Array.prototype.sort.call(arr, (a, b) => order === "asc" ? (a - b) : (b - a));
    case "ascAlpha":
      return arr.sort();
    case "descAlpha":
      return arr.reverse();
    default:
      return arr;
  }
};
},{}],29:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = (array, n) => {
  let i = 0;
  let tasks = [];
  let size = Math.ceil(array.length/n);
  if(array.slice) {
    while(i < array.length) {
      tasks.push(array.slice(i, i += size));
    }
  } else {
    while (i < array.length) {
      tasks.push(array.subarray(i, i += size));
    }
  }
  return tasks;
};
},{}],30:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const executeTask = require("../../hamsters-run");

module.exports = (inputString, onSuccess) => {
	let params = {
		input: inputString
	};
  executeTask(params, () => {
    rtn.data = JSON.parse(params.input);
  }, (output) => {
    onSuccess(output[0]);
  });
};
},{"../../hamsters-run":17}],31:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = (json, onSuccess) => {
  let params = {
  	input: inputJson
  };
  run({input: json}, () => {
    rtn.data = JSON.stringify(params.input);
  }, (output) => {
    onSuccess(output[0]);
  });
};
},{}],32:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const stringifyJSON = require("./json/stringify-json");
const parseJSON = require("./json/parse-json");
const randomArray = require("./array/random-array");
const aggregateArrays = require("./array/aggregate-arrays");
const sortArray = require("./array/sort-array");
const splitArray = require("./array/split-array");
const loopAbstraction = require("./abstractions/loop-abstraction");

const hamsterTools = {
	stringifyJson: stringifyJSON,
	parseJson: parseJSON,
	randomArray: randomArray,
	aggregate: aggregateArrays,
	sort: sortArray,
	splitArray: splitArray,
	loop: loopAbstraction 
};

module.exports = () => {
	return hamsterTools;
};
},{"./abstractions/loop-abstraction":25,"./array/aggregate-arrays":26,"./array/random-array":27,"./array/sort-array":28,"./array/split-array":29,"./json/parse-json":30,"./json/stringify-json":31}],33:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = (textContent) => {
  if(!Blob) {
    var BlobBuilder = BlobBuilder || WebKitBlobBuilder || MozBlobBuilder || MSBlobBuilder;
    var blob = new BlobBuilder();
    blob.append([textContent], {
      type: 'application/javascript'
    });
    return blob.getBlob();
  } 
  return new Blob([textContent], {
    type: 'application/javascript'
  });
};
},{}],34:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = (output, aggregate, dataType) => {
  if(aggregate && output.length <= 20) {
    return aggregate(output, dataType);
  }
  return output;
};
},{}],35:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const createBlob = require("./create-blob");
const giveHamsterWork = require("../../processor/hamster-worker");

module.exports = () => {
  return URL.createObjectURL(createBlob('(' + String(giveHamsterWork()) + ')();'));
};
},{"../../processor/hamster-worker":19,"./create-blob":33}],36:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

module.exports = {
  types: {
    "uint32": Uint32Array,
    "uint16": Uint16Array,
    "uint8": Uint8Array,
    "uint8clamped": Uint8ClampedArray,
    "int32": Int32Array,
    "int16": Int16Array,
    "int8": Int8Array,
    "float32": Float32Array,
    "float64": Float64Array
  },
  processData: (dataType, buffer) => {
    if(!this.types[dataType]) {
      return dataType;
    }
    return new this.types[dataType](buffer);
  },
  processDataType: (dataType, buffer) => {
    if(transferrable) {
      return this.processData(dataType, buffer);
    }
    return buffer;
  },
};

},{}],37:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const legacyProcessor = require("../processor/legacy-processor");
const modernProcessor = require("../processor/modern-processor");
const environment = require("../environment/setup-environment");

module.exports = () => {
	if(environment.legacy) {
		return legacyProcessor;
	}
	return modernProcessor;
};
},{"../environment/setup-environment":11,"../processor/legacy-processor":20,"../processor/modern-processor":21}],38:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const runningTasks = require('../../pool/thread-pool').runningTasks;

module.exports = (task, id) => {
  runningTasks.splice(runningTasks.indexOf(id), 1); //Remove thread from running pool
  task.workers.splice(task.workers.indexOf(id), 1); //Remove thread from task running pool
};
},{"../../pool/thread-pool":18}],39:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const environment = require('../../environment/setup-environment');

module.exports = (functionBody) => {    
	if(!environment.legacy) {
    let stringifiedFunction = String(functionBody);
    
    if(!environment.worker) {
      var startingIndex = (stringifiedFunction.indexOf("{") + 1);
      var endingIndex = (stringifiedFunction.length - 1);
      return stringifiedFunction.substring(startingIndex, endingIndex);
    }
  }
  return functionBody;
}
},{"../../environment/setup-environment":11}],40:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const environment = require('../../environment/setup-environment');

module.exports = (hamster, food) => {
  if(environment.worker) {
    return hamster.port.postMessage(food);
  }
  if(environment.ie10) {
    return hamster.postMessage(food);
  }
  let buffers = [], key;
  for(key in food) {
    if(food.hasOwnProperty(key) && food[key] && food[key].buffer) {
      buffers.push(food[key].buffer);
    }
  }
  return hamster.postMessage(food,  buffers);
};
},{"../../environment/setup-environment":11}],41:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";


const environment = require("../../environment/setup-environment");
const giveHamsterWork = require("../../processor/hamster-worker");
const uri = require("../data/new-uri");

module.exports = () => {
  if(environment.ie10) {
		return new Worker("../../../common/wheel.min.js");
  } else if(environment.node) {
    return new Worker(giveHamsterWork());
  } else if(environment.worker) {
    return new SharedWorker(hamsters.wheel.uri, 'SharedHamsterWheel');
  } else {
    return new Worker(uri);
  }
};



},{"../../environment/setup-environment":11,"../../processor/hamster-worker":19,"../data/new-uri":35}],42:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";

const environment = require("../../environment/setup-environment");

module.exports = (id, aggregate, callback, task, hamster, memoize) => {
  return (e) => {
    if(!environment.worker) {
      hamster.terminate(); //Kill the thread
    }
    // errors.push({
    //   msg: "Error Hamster #" + id + ": Line " + e.lineno + " in " + e.filename + ": " + e.message
    // });
    console.error("Error Hamster #" + id + ": Line " + e.lineno + " in " + e.filename + ": " + e.message);
  }  
};
},{"../../environment/setup-environment":11}],43:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";


const environment = require("../../environment/setup-environment");
const sortOutput = require("../../tools/array/sort-array");
const processQueue = require('../../pool/thread-pool');
const cleanTask = require('../task/clean-task');

module.exports = (id, aggregate, onSuccess, task, hamster, memoize) => {
  cleanTask(task, id);
  let results = e.data.results;
  task.output[id] = results.data;
  // if(debug === "verbose") {
  //   console.info("Hamster #" + id + " finished " + "@ " + e.timeStamp);
  // }
  if(task.workers.length === 0 && task.count === task.threads) {
    if(task.order) {
      onSuccess(sortOutput(getOutput(task.output, aggregate, results.dataType), task.order));
    } else {
      onSuccess(getOutput(task.output, aggregate, results.dataType));
    }
    // if(debug) {
    //   console.info("Execution Complete! Elapsed: " + ((e.timeStamp - task.input[0].start)/1000) + "s");
    // }
    tasks[task.id] = null; //Clean up our task, not needed any longer
  }
  if(threadPool.pendingTasks.length !== 0) {
    processQueue(hamster, threadPool.pendingTasks.shift());
  } else if(!persistence && !environment.worker) {
    hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)
  }
};
},{"../../environment/setup-environment":11,"../../pool/thread-pool":18,"../../tools/array/sort-array":28,"../task/clean-task":38}],44:[function(require,module,exports){
/*
* Title: Hamsters.js
* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
* Author: Austin K. Smith
* Contact: austin@asmithdev.com
* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
* License: Artistic License 2.0
*/

"use strict";


const environment = require("../../environment/setup-environment");
const onMessage = require('./on-message');
const onError = require('./on-error');

module.exports = (id, aggregate, callback, task, hamster, memoize) => {
  let trainingMessageData = onMessage(id, aggregate, callback, task, hamster, memoize);
  let trainingErrorData = onError(id, aggregate, callback, task, hamster, memoize);
  
  if(environment.worker) {
    hamster.port.onmessage = trainingMessageData;
    hamster.port.onerror = trainingErrorData;
  } else {
    hamster.onmessage = trainingMessageData;
    hamster.onerror = trainingErrorData;
  }   
};
},{"../../environment/setup-environment":11,"./on-error":42,"./on-message":43}]},{},[16])